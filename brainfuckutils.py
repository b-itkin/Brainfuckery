#!/usr/bin/python3
#Author: Brady Itkin
#Date created: 2/19/2016
#Last modified 2/23/2016
#Part of my CS project
#Initial research for this code done on www.en.wikipedia.org/wiki/Brainfuck
#########################
from string import Template
import sys

#Compiler/interpreter error return codes
########################################
SUCCESS=0
MISMATCH_BRACKET=1
#PROGRAMSIZE=2
MAXTAPESIZE=3
MAXVALUE=4
END=5
########################
#Interpreter behavior
########################
#Cell sizes:
MAXVAL_CHAR=0 #-128 to 127
#MAXVAL_UCHAR=1 #0 to 255
MAXVAL_INT=2 #-sys.maxsize to sys.maxsize
#########################################
#output C header and footer
#########################################
header=Template("""#include <stdio.h>
#include <stdlib.h>
#define TAPESIZE $tapesz
/*Object file generated by the BFtoC compiler*/

int main(void) {
char * tape=malloc(sizeof(char)*TAPESIZE);
char * pointer=tape;

""")

footer="""free(tape);
return 0;
}
"""
##########################################
#Class: BracketStack
#Performs all checks on brainfuck brackets for compiler and interpreter
############################################
class BracketStack:
	program=""
	bracket_level=0
	positionList=[]
		
	def __init__(self,program_=None):
		self.program=program_	
	def pushChk(self): #Used by compiler and interpreter
		self.bracket_level+=1
	def popChk(self): #Used by compiler and interpreter
		self.bracket_level-=1
	def push(self,position): #Used by interpeter
		self.bracket_level+=1
		self.positionList.append(position)
	def pop(self): #Used by interpeter
		if (self.bracket_level==0):
			return -1 #Danger will robinson! Mismatching brackets.
		else:
			self.bracket_level-=1
			return self.positionList.pop()
	def checkBrackets(self):
		for c in self.program:
			if c is '[':
				self.pushChk()
			elif c is ']':
				self.popChk()
		if self.bracket_level is not 0:
			return 1
		else:
			return 0
########################################################################################
#Class: BrainFuckInterpreter
#The class that handles interpreting Brainfuck if the - option on the commandline is used
#########################################################################################
class BrainFuckInterpreter:
	program=None #String
	maxvaluemode=MAXVAL_INT 
	maxvalue=sys.maxsize
	tapesize=0
	tape=None
	tape_index=0
	bracketControl=BracketStack()
	program_position=0 #Where we are in the program
	
	def __init__(self,maxval,tapesz,program=None):
		self.maxvaluemode=maxval
		self.tapesize=tapesz
		self.initializeInterpreter()
		self.program=program
	def initializeInterpreter(self):
		self.tape=[]
		for i in range(self.tapesize):
			self.tape.append(0)
		if (self.maxvaluemode==MAXVAL_INT):
			self.maxvalue=sys.maxsize
		elif (self.maxvaluemode==MAXVAL_CHAR):
			self.maxvalue=127

	def loadCommands(self,commands,checkBrackets=True):
		bracketChecker=None		
		if (checkBrackets):
			bracketChecker=BracketStack(commands)
			if (bracketChecker.checkBrackets()):
				return MISMATCH_BRACKET
		if (self.program is None):
			self.program=commands
			return SUCCESS		
		self.program+=commands
		return SUCCESS
	def nextCommand(self):
		if (self.program_position>=len(self.program)):
			return END
		else:
			return self.executeCommand(self.program[self.program_position])
	def skipToRightBracket(self):
		displacement=1
		bracketChk=BracketStack()
		for c in self.program[self.program_position+1:]:
			if (c=='['):
				bracketChk.pushChk()
				displacement+=1			
			elif (c==']' and bracketChk.bracket_level==0):
				displacement+=1 #We want the command after the ]
				break
			elif (c==']'):
				bracketChk.popChk()
				displacement+=1
			else:
				displacement+=1
		
		self.program_position+=displacement
		return SUCCESS
	def executeCommand(self,command):		
		temp_position=0 #Initialize to garbage
		inputchar="CC" #Initialize to garbage		
		if (command=='>'): #Move the index to the right one
			if (self.tape_index+1==self.tapesize):
				return MAXTAPESIZE			
			self.tape_index+=1
			self.program_position+=1
			return SUCCESS
		elif (command=='<'): #Move the index to the left one
			if (0-self.tape_index==self.tapesize):
				return MAXTAPESIZE
			self.tape_index-=1
			self.program_position+=1
			return SUCCESS
		elif (command=='+'): #Add one to the current value on the tape
			if (self.maxvalue==self.tape[self.tape_index]+1):
				return MAXVALUE	
			self.tape[self.tape_index]+=1
			self.program_position+=1
			return SUCCESS
		elif (command=='-'): #Subtract one to the current value on the tape
			if (self.maxvalue==0-self.tape[self.tape_index]+1):
				return MAXVALUE
			self.tape[self.tape_index]-=1
			self.program_position+=1
			return SUCCESS
		elif (command=='['): #"while(*pointer) {"
			
			if (self.tape[self.tape_index]==0):
				self.skipToRightBracket()
				return SUCCESS
				
			self.bracketControl.push(self.program_position)
			
			self.program_position+=1
			return SUCCESS
		elif (command==']'): #"}"
			temp_position=self.bracketControl.pop()
			
			if (temp_position==-1):
				return MISMATCH_BRACKET
			self.program_position=temp_position
			return SUCCESS
		elif (command=='.'): #Print the character on the tape to the screen
			#print("Printing...")
			print(chr(self.tape[self.tape_index]),end="")
			self.program_position+=1
			return SUCCESS
		elif (command==','): #Take input from the user
			while (len(inputchar)!=1):
				inputchar=input("Input ONE character: ")
			self.tape[self.tape_index]=ord(inputchar) #Ord converts the character to a python integer, because it's an object, not just a simple number like in C :(
			self.program_position+=1

		else:
			self.program_position+=1
			return SUCCESS
			

class BrainFuckParser:
	program=""
	maxvalue=0
	#maxprogramsize=0
	tapesize=0
	commandDict={">":"++pointer;\n", "<":"--pointer;\n", "+":"++*pointer;\n", "-":"--*pointer;\n", \
		".":"putchar(*pointer);\n", ",":"*pointer=getchar();\n", "[":"while (*pointer) {\n", "]":"}"} #Since I didn't have the time to put in optimizations, this'll do for now.
	return_code=0
	def __init__(self,program_,maxprogamsize_,tapesize_):
		self.program=program_
		#maxvalue=maxvalue_
		#self.maxprogramsize=maxprogramsize_
		self.tapesize=tapesize_
	#def checkProgramSize(self):
	#	
	#	return 0		
	def checkBrackets(self):
		bracketChecker=BracketStack(self.program)
		if not bracketChecker.checkBrackets():
			return 0
		else:
			return 1

	def substitute(self,command):
		if (command in self.commandDict):
			return self.commandDict[command]
		else:
			return None
	def generateHeader(self):
		return header.substitute(tapesz=self.tapesize)	
	def compileProgram(self):
		returnTuple=None #What we'll return to main()
		compiledCProg=None #returnTuple[1]
		token=""
		#if (self.checkProgramSize()):
		#	returnTuple=(PROGRAMSIZE,None)
		#	return returnTuple
		if (self.checkBrackets()):
			returnTuple=(MISMATCH_BRACKET,None)
			return returnTuple
		compiledCProg=self.generateHeader()
		for c in self.program:
			token=self.substitute(c)
			if (token is not None):
				compiledCProg=compiledCProg+token 
		
		compiledCProg=compiledCProg+footer
		returnTuple=(0,compiledCProg)
		return returnTuple
		
